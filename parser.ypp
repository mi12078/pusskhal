%{
#include <iostream>
#include <string>
#include <vector>
#include <cstdlib>
#include "symtab.hpp"
#include "exprAST.hpp"
#include "stmtAST.hpp"

#define YYDEBUG 1

extern int yylex();

SymbolTable st = SymbolTable::get();

void yyerror(std::string s)
{
	std::cerr << s << std::endl;
	exit(1);
}
%}

%union {
	int i;
	double r;
	std::string *s;
	std::string *id;
	ExprAST* expression;
	std::vector<std::string> *strVec;
}

%token PROGRAM CONST TYPE VAR PROCEDURE FUNCTION BEGINT END WHILE NOT
%token DO IF OF THEN FOR TO DOWNTO READLN WRITELN
%token INTEGERTYPE REALTYPE STRINGTYPE BOOLEANTYPE
%token ARRAY REAL STRING
%token TRUE FALSE EOFT
%token UMINUS

%token<s> ID
%token<i> INTEGER


%type<strVec> var_list
%type<expression> expr

%right ":="
%left '='
%left '<' '>'
%left '['
%left '+' '-'
%left '*' '/'
%nonassoc UMINUS

%%

/*program*/
program: program_heading ';' program_block
;
program_heading: PROGRAM ID
| PROGRAM ID '(' program_parameters ')'
;
program_parameters: program_parameters ',' ID
| ID
;
program_block: block '.'
;
block: const_defs type_defs var_decls proc_func_decls stmt_part
;

/*constants*/
const_defs: CONST const_def_list
|
;
const_def_list: const_def_list const_def
| const_def
;
const_def: ID '=' INTEGER ';'
;

/*types*/
type_defs: TYPE type_def_list
|
;
type_def_list: type_def_list type_def
| type_def
;
type_def: ID '=' type ';'
;

/*variables*/
var_decls: VAR var_decl_list {

}
|
;
var_decl_list: var_decl_list var_decl {

}
| var_decl {

}
;
var_decl: var_list ':' type ';' {
	switch($3)
	{
		case INTEGERTYPE:
			for(auto s=$1.begin(); s!=$1.end(); ++s)
			{
				SymInfo *info = new BasicSym<int>(new IntegerType, 0);
				st.insertSymbol(*s, info);
			}
		break;
		case STRINGTYPE:
		break;
		case BOOLEANTYPE:
		break;
		case REALTYPE:
		break;
		case ARRAYTYPE:
		break;
		case INTEGERTYPE:
		break;
	}
}
;
var_list: var_list ',' ID {
	$$ = $1;
	$$->push_back(*$3);
	delete $3;
}
| ID {
	$$ = new std::vector<std::string>();
	$$->push_back(*$1);
	delete $1;
}

;
type: INTEGERTYPE 
| REALTYPE
| STRINGTYPE
| BOOLEANTYPE
| arraytype
| ID
; 
arraytype: ARRAY range_list OF type
;
range_list: range_list ',' range
| range
;
range: '[' id_or_num '.''.' id_or_num ']'
;
id_or_num: ID
| INTEGER
;

/*procedures & functions*/
proc_func_decls: proc_func_decls ';' proc_func_decl 
| proc_func_decl 

;
proc_func_decl : proc_decl
| func_decl
|
;
proc_decl: PROCEDURE ID proc_func_param_list ';' block
;
func_decl: FUNCTION ID proc_func_param_list ':' type ';' block
;
proc_func_param_list : '(' proc_func_params ')'
|
;
proc_func_params: proc_func_params ';' proc_func_param
| proc_func_param
;
proc_func_param: var_list ':' type
;

/*statements*/
stmt_part: compound_statement
;
compound_statement: BEGINT statement_seq END
;
statement_seq: statement_seq ';' statement
| statement
;
statement: assignment
| if_stmt
| for_stmt
| while_stmt
| proc_func_call
| ID /*poziv fje/proc*/ {

}
| compound_statement
|
;

expr: expr '+' expr {
	if($1->type() != $3->type())
		yyerror("Conflicting types");
	$$ = new BinaryExprAST('+', $1, $3, $1->clone());
}
| expr '-' expr
| expr '*' expr
| expr '/' expr
| expr '<' expr
| expr '>' expr
| '-' expr %prec UMINUS
| '(' expr ')'
| TRUE
| FALSE
| ID '[' expr ']'
| ID /*moze biti i fja/proc bez args*/
| proc_func_call
| INTEGER {
	$$ = new ConstExprAst<int>($1, new IntegerType);
}
| REAL
| STRING
;

bool_rel_expr: NOT bool_rel_expr
| expr '>' expr
| expr '<' expr
| expr '=' expr
| TRUE
| FALSE
| EOFT
;

assignment: ID ':''=' expr {
	/*provera da li je simbol u tablici*/
	SymInfo* i = st.searchTable(*$1);
	if(i == nullptr)
		yyerror("Nonexistent symbol");

	/*provera tipa simbola i tipa rhs*/
	if(i->type() != $4->type())
		yyerror("Conflicting types");

	$$ = new AssignStmtAST($1, $4);
	delete $1;
}
| ID '[' expr ']' ':''=' expr 
;

if_stmt: IF bool_rel_expr THEN statement
;

for_stmt: FOR assignment TO expr DO statement
| FOR assignment DOWNTO expr DO statement
;

while_stmt: WHILE bool_rel_expr DO statement
;

proc_func_call: ID '(' proc_func_arg_list ')'
;
proc_func_arg_list: proc_func_arg_list ',' proc_func_arg
| proc_func_arg
;
proc_func_arg: expr
|
;


%%

int main()
{
	//yydebug = 1;
	yyparse();
}
