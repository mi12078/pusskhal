%{
#include <iostream>
#include <string>
#include <vector>
#include <cstdlib>
#include "symTab.hpp"
#include "exprAST.hpp"
#include "stmtAST.hpp"

#define YYDEBUG 1

extern int yylex();

SymbolTable st = SymbolTable::get();

void yyerror(std::string s)
{
	std::cerr << s << std::endl;
	exit(1);
}

struct blkStruct
{
	std::vector<std::pair<std::string, TypeAST*> > *params;
	StmtAST *stmts;
}
%}

%union {
	int i;
	double r;
	std::string *s;
	std::string *id;
	ExprAST *expr;
	TypeAST *ty;
	StmtAST *stmt;
	std::vector<std::string> *strVec;
	std::vector<StmtAST*> *stmtVec;
	std::vector<std::pair<std::string, TypeAST*> > *pfp;
	blkStruct *blks;
}

%token PROGRAM CONST TYPE VAR PROCEDURE FUNCTION BEGINT END WHILE NOT
%token DO IF OF THEN FOR TO DOWNTO READLN WRITELN
%token INTEGERTYPE REALTYPE STRINGTYPE BOOLEANTYPE
%token ARRAY REAL STRING
%token TRUE FALSE EOFT
%token UMINUS

%token<s> ID
%token<i> INTEGER


%type<strVec> var_list
%type<expr> expr
%type<ty> type;
%type<pfp> proc_func_param var_decl var_decl_list var_decls 
%type<pfp> proc_func_params  proc_func_param_list 
%type<stmt> statement assignment if_stmt for_stmt while_stmt
%type<stmt> proc_func_call compound_statement stmt_part
%type<stmtVec> statement_seq

%right ":="
%left '='
%left '<' '>'
%left '['
%left '+' '-'
%left '*' '/'
%nonassoc UMINUS

%%

/*program*/
program: program_heading ';' program_block
;
program_heading: PROGRAM ID
| PROGRAM ID '(' program_parameters ')'
;
program_parameters: program_parameters ',' ID
| ID
;
program_block: block '.'
;
/*shit, pascal allows nested functions...
 *can we ignore that, since block is used only in the
 *program block and inside procs/fns? */
/*consider only vars and stmts part*/
block: const_defs type_defs var_decls proc_func_decls stmt_part {
	/*we need to pass proc_func_decls as well for the main program
	 *but ignore it when in func_decl?*/
	$$ = new blkStruct;
	$$->params = $3;
	$$->stmts = $5;
}
;

/*constants*/
const_defs: CONST const_def_list
|
;
const_def_list: const_def_list const_def
| const_def
;
const_def: ID '=' INTEGER ';'
;

/*types*/
type_defs: TYPE type_def_list
|
;
type_def_list: type_def_list type_def
| type_def
;
type_def: ID '=' type ';'
;

/*variables*/
var_decls: VAR var_decl_list { $$ = $1; }
| { $$ = std::vector<std::pair<std::string, TypeAST*> >(); }
;
var_decl_list: var_decl_list var_decl {
	$$ = $1;
	for(auto e: *$2)
		$$->push_back(e);
}
| var_decl {
	$$ = std::vector<std::pair<std::string, TypeAST*> >();
	for(auto e: *$1)
		$$->push_back(e);
	//delete $1? w8, TypeAST*s would need to be copied then...
}
;
var_decl: var_list ':' type ';' {
	$$ = new std::vector<std::pair<std::string, TypeAST*> >();
	for(auto e: *$1)
		$$->push_back(std::make_pair(e, $3));
	//delete $3;
}
;
var_list: var_list ',' ID {
	$$ = $1;
	$$->push_back(*$3);
	//delete $3;
}
| ID {
	$$ = new std::vector<std::string>();
	$$->push_back(*$1);
	//delete $1;
}

;
type: INTEGERTYPE {
	$$ = new IntegerType;
}
| REALTYPE
| STRINGTYPE
| BOOLEANTYPE
| arraytype
/*| ID */
; 
arraytype: ARRAY range_list OF type
;
range_list: range_list ',' range
| range
;
range: '[' id_or_num '.''.' id_or_num ']'
;
id_or_num: ID
| INTEGER
;

/*procedures & functions*/
proc_func_decls: proc_func_decls ';' proc_func_decl 
| proc_func_decl 

;
proc_func_decl : proc_decl
| func_decl
|
;
proc_decl: PROCEDURE ID proc_func_param_list ';' block
;
func_decl: FUNCTION ID proc_func_param_list ':' type ';' block {
	/*extract var_decls from block, merge it with
	 * proc_func_param_list, then passing it to the ctr*/
	for(auto e: *$7->params)
	{
		$3->push_back(e);
	}
	$$ = new FnDeclStmtAST(*$2, $3, $5, $7->stmts);
}
;
proc_func_param_list : '(' proc_func_params ')' { $$ = $2; }
| {	$$ = new std::vector<std::pair<std::string, TypeAST*> >(); }
;
proc_func_params: proc_func_params ';' proc_func_param {
	$$ = $1;
	for(auto e: *$3)
		$$->push_back(e);
}
| proc_func_param {
	$$ = new std::vector<std::pair<std::string, TypeAST*> >();
	for(auto e: *$1)
		$$->push_back(e);
}
;
proc_func_param: var_list ':' type {
	$$ = new std::vector<std::pair<std::string, TypeAST*> >();
	for(auto e : *$1)
		$$->push_back(std::make_pair(e, $3);
}
;

/*statements*/
stmt_part: compound_statement {
	$$ = $1;
}
;
compound_statement: BEGINT statement_seq END {
	/*do we create the node here, or above in the block?
	 *Presumably we do, compund can appear in other places than
	 *a function or the program main block.*/
	$$ = new CompoundStmtAST(*$2);
}
;
statement_seq: statement_seq ';' statement {
	$$ = $1;
	$$->push_back($3);
}
| statement { 
	$$ = new std::vector<StmtAST*>();
	$$->push_back($1);
}
;
statement: assignment { $$ = $1; }
| if_stmt { $$ = $1; }
| for_stmt { $$ = $1; }
| while_stmt { $$ = $1; }
| proc_func_call { $$ = $1; }
| ID /*poziv fje/proc*/
| compound_statement { $$ = $1; }
| 
;

expr: expr '+' expr {
	if($1->type() != $3->type())
		yyerror("Conflicting types");
	$$ = new BinaryExprAST('+', $1, $3, $1->clone());
}
| expr '-' expr
| expr '*' expr
| expr '/' expr
| expr '<' expr
| expr '>' expr
| '-' expr %prec UMINUS
| '(' expr ')'
| TRUE
| FALSE
| ID '[' expr ']'
| ID /*moze biti i fja/proc bez args*/
| proc_func_call {
}
| INTEGER {
	$$ = new IntegerExprAst($1, new IntegerType);
}
| REAL
| STRING
;

bool_rel_expr: NOT bool_rel_expr
| expr '>' expr
| expr '<' expr
| expr '=' expr
| TRUE
| FALSE
| EOFT
;

assignment: ID ':''=' expr {
	/*provera da li je simbol u tablici*/
	SymInfo* i = st.searchTable(*$1);
	if(i == nullptr)
		yyerror("Nonexistent symbol");

	/*provera tipa simbola i tipa rhs*/
	if(i->type() != $4->type())
		yyerror("Conflicting types");

	$$ = new AssignStmtAST($1, $4);
	//delete $1;
}
| ID '[' expr ']' ':''=' expr 
;

if_stmt: IF bool_rel_expr THEN statement
;

for_stmt: FOR assignment TO expr DO statement
| FOR assignment DOWNTO expr DO statement
;

while_stmt: WHILE bool_rel_expr DO statement
;

proc_func_call: ID '(' proc_func_arg_list ')'
;
proc_func_arg_list: proc_func_arg_list ',' proc_func_arg
| proc_func_arg
;
proc_func_arg: expr
|
;


%%

int main()
{
	//yydebug = 1;
	yyparse();
}
